<!-- TOC -->

- [1. 数据结构和算法概述](#1-数据结构和算法概述)
  - [1.1. 数据结构](#11-数据结构)
  - [1.2. 数据结构分类](#12-数据结构分类)
    - [1.2.1. 逻辑结构](#121-逻辑结构)
      - [1.2.1.1. 集合结构](#1211-集合结构)
      - [1.2.1.2. 线性结构](#1212-线性结构)
      - [1.2.1.3. 树型结构](#1213-树型结构)
      - [1.2.1.4. 图形结构](#1214-图形结构)
    - [1.2.2. 物理结构](#122-物理结构)
      - [1.2.2.1. 顺序结构](#1221-顺序结构)
      - [1.2.2.2. 链式存储结构](#1222-链式存储结构)
  - [1.3. 算法](#13-算法)
        - [1.3.0.2.1. 计算1到100的和](#13021-计算1到100的和)
        - [1.3.0.2.2. 计算10的阶乘](#13022-计算10的阶乘)
- [2. 算法分析](#2-算法分析)
  - [2.1. 算法的时间复杂度分析](#21-算法的时间复杂度分析)
    - [2.1.1. 事后分析方法](#211-事后分析方法)
    - [2.1.2. 事前分析方法](#212-事前分析方法)
    - [2.1.3. 函数渐近增长](#213-函数渐近增长)
    - [2.1.4. 大O记法](#214-大o记法)
      - [2.1.4.1. 常见的大O阶](#2141-常见的大o阶)
        - [2.1.4.1.1. 线性阶](#21411-线性阶)
        - [2.1.4.1.2. 平方阶](#21412-平方阶)
        - [2.1.4.1.3. 立方阶](#21413-立方阶)
        - [2.1.4.1.4. 对数阶](#21414-对数阶)
        - [2.1.4.1.5. 常数阶](#21415-常数阶)
        - [2.1.4.1.6. 最坏的情况](#21416-最坏的情况)
  - [2.2. 算法的空间复杂度分析](#22-算法的空间复杂度分析)
- [简单排序](#简单排序)
  - [Comparable接口介绍](#comparable接口介绍)
  - [冒泡排序](#冒泡排序)
        - [冒泡排序的时间复杂度分析](#冒泡排序的时间复杂度分析)
  - [选择排序](#选择排序)
        - [选择排序的时间复杂度](#选择排序的时间复杂度)
  - [插入排序](#插入排序)

<!-- /TOC -->

# 1. 数据结构和算法概述
## 1.1. 数据结构
数据结构是研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。用来组织和存储数据
## 1.2. 数据结构分类
### 1.2.1. 逻辑结构
#### 1.2.1.1. 集合结构
数据元素除了属于同一个集合，没有任何关系
#### 1.2.1.2. 线性结构
数据元素之间存在一对一关系
#### 1.2.1.3. 树型结构
存在一对多的层次关系
#### 1.2.1.4. 图形结构
多对多关系
### 1.2.2. 物理结构
逻辑结构在计算机中的真正的表示方式
#### 1.2.2.1. 顺序结构
数据单元内存地址是连续的
* 好处：方便访问
* 坏处：插入、删除需要多个元素挪位，耗时
#### 1.2.2.2. 链式存储结构
存储单元可以是连续，也可以是不连续的
* 好处：插入、删除方便
## 1.3. 算法
根据一定条件，对一些数据进行计算，得到需要的结果
##### 1.3.0.2.1. 计算1到100的和
公式求解
##### 1.3.0.2.2. 计算10的阶乘
递归占用内存太大，直接for循环
# 2. 算法分析
## 2.1. 算法的时间复杂度分析
### 2.1.1. 事后分析方法
在算法执行前后定位，得到运行时间
### 2.1.2. 事前分析方法
根据统计方法进行估算，涉及到
* **算法采用的策略和方案**
* 编译产生的代码质量 x
* **问题的输入规模**
* 机器执行指令的速度 x
最重要的是把核心操作的次数和输入规模关联起来
### 2.1.3. 函数渐近增长
给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。
* 随着输入规模的增大，与最高次项相乘的常数可以忽略
* 算法函数中n最高次幂越小，算法效率越高
* 算法函数中的常数可以忽略
* 算法函数中最高次幂的常数因子可以忽略
* 算法函数中最高次幂越小，算法效率越高
### 2.1.4. 大O记法
程序执行次数=执行时间。
* 用常数1取代运行事件中所有加法常数
* 在修改后的运行次数中，只保留高阶项
* 如果高阶项存在，且常数因子不为1，则去除与这个项相乘的常数
#### 2.1.4.1. 常见的大O阶
##### 2.1.4.1.1. 线性阶
一般含有嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，时间复杂度为O(n)
##### 2.1.4.1.2. 平方阶
嵌套循环，时间复杂度极为O(n²)
##### 2.1.4.1.3. 立方阶
三层嵌套循环
##### 2.1.4.1.4. 对数阶
O(logn)，分析算法的增长率时与对数的底数无关
##### 2.1.4.1.5. 常数阶
O(1)
##### 2.1.4.1.6. 最坏的情况
最坏的情况是一种保证，在应用中，这是一种基本的保证，因此一般用最坏的情况作为时间复杂度分析
## 2.2. 算法的空间复杂度分析
* byte占用1个字节，short占用2个字节，int类型占用4个字节，long类型占用8个字节，float类型占用4个字节，double类型占用8个字节，boolean占用1个字节，char类型占用2个字节
* 计算机访问内存以字节读取，一个字节占用8bit
* 一个引用占用（机器地址）需要8个字节表示，例:Data data = new Data()，则data这个变量占用8个字节
* 创建一个对象，比如new Data()，除了Data对象内部存储的数据（例如年月日等信息）占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息
* 一般内存的使用，如果不够8个字节，都会被自动填充为8字节

    public class A{
        public int a=1;
    }
    整形成员变量a占用4个字节，对象本身占用16个字节，创建该对象需要20个字节，但由于不是以8为单位的，会自动填充为24字节
* java中数组被限定为对象，一般因为记录长度需要额外的内存，一般需要24字节的头信息，其中16个字节用来保存对象，4个字节保存长度，4个字节填充
* 一般不对空间复杂度进行估算（嵌入式开发除外），默认复杂度为时间复杂度
# 简单排序
## Comparable接口介绍
用来定义排序规则
实现方法
```java
// 首先在子对象中继承接口Comparable<子对象名称>，然后重写方法
public class Student implements Comparable<Student>{
@Override
  public int compareTo(Student o) {
      return this.age-o.age;
  }
// 然后在主程序中定义子函数调用接口对象，多态的形式，最后在主函数中使用子函数
Student s1 = new Student("张三",22);
Student s2 = new Student("李四",33);
public static Comparable getMax(Comparable c1,Comparable c2)
int result =c1.compareTo(c2);
return result>0?c1:c2;
```
## 冒泡排序
比较相邻的两个数据，大的往后放，重复n-1+n-2+n=3...1次
冒泡API设计
|类名|Bubble|
|:--|:--|
|构造方法|Bubble()：创建对象|
|成员方法|1、public static void sort(Comparable[] a):对数组内的元素进行排序<br>2、private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3、private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和j处的值|
##### 冒泡排序的时间复杂度分析
在最坏情况下，逆序数组，每次比较都需要交换数据
元素比较的次数：(N-1)+(N-2)...1
元素交换的次数与上一样
总执行次数为O(N²)
## 选择排序
* 每次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值进行比较，如果当前索引处的值大于其他某个元素中的值，则重新假定为最小值，最后找到最小值所在索引
* 交换第一个索引处和最小值所在的索引处的值
|类名|Selection|
|:--|:--|
|构造方法|Selection():创建Selection对象|
|成员方法|1、public static void sort(Comparable[] a):对数组内的元素进行排序<br>2、private static boolean greater(comparable v,Comparable w):判断v是否大于w<br>3、private static void ecxh(Comparable[] a,int i,int j)|
##### 选择排序的时间复杂度
元素比较次数：N^2/2-N/2
元素交换次数：N-1
时间复杂度为O(N²)
## 插入排序
* 把所有元素分为两组，已排序和未排序
* 找到未排序中的第一个数，向已经排序的组中插入
* 倒叙遍历已经排序的元素，依次将待插入元素进行比较，直到找到一个元素小于等于待插入元素
|类名|Selection|
|:--|:--|