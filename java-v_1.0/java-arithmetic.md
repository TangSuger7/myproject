<!-- TOC -->

- [1. 数据结构和算法概述](#1-数据结构和算法概述)
  - [1.1. 数据结构](#11-数据结构)
  - [1.2. 数据结构分类](#12-数据结构分类)
    - [1.2.1. 逻辑结构](#121-逻辑结构)
      - [1.2.1.1. 集合结构](#1211-集合结构)
      - [1.2.1.2. 线性结构](#1212-线性结构)
      - [1.2.1.3. 树型结构](#1213-树型结构)
      - [1.2.1.4. 图形结构](#1214-图形结构)
    - [1.2.2. 物理结构](#122-物理结构)
      - [1.2.2.1. 顺序结构](#1221-顺序结构)
      - [1.2.2.2. 链式存储结构](#1222-链式存储结构)
  - [1.3. 算法](#13-算法)
        - [1.3.0.2.1. 计算1到100的和](#13021-计算1到100的和)
        - [1.3.0.2.2. 计算10的阶乘](#13022-计算10的阶乘)
- [2. 算法分析](#2-算法分析)
  - [2.1. 算法的时间复杂度分析](#21-算法的时间复杂度分析)
    - [2.1.1. 事后分析方法](#211-事后分析方法)
    - [2.1.2. 事前分析方法](#212-事前分析方法)
    - [2.1.3. 函数渐近增长](#213-函数渐近增长)
    - [2.1.4. 大O记法](#214-大o记法)
      - [2.1.4.1. 常见的大O阶](#2141-常见的大o阶)
        - [2.1.4.1.1. 线性阶](#21411-线性阶)
        - [2.1.4.1.2. 平方阶](#21412-平方阶)
        - [2.1.4.1.3. 立方阶](#21413-立方阶)
        - [2.1.4.1.4. 对数阶](#21414-对数阶)
        - [2.1.4.1.5. 常数阶](#21415-常数阶)
        - [2.1.4.1.6. 最坏的情况](#21416-最坏的情况)
  - [2.2. 算法的空间复杂度分析](#22-算法的空间复杂度分析)
- [3. 简单排序](#3-简单排序)
  - [3.1. Comparable接口介绍](#31-comparable接口介绍)
  - [3.2. 冒泡排序](#32-冒泡排序)
        - [3.2.0.1.7. 冒泡排序的时间复杂度分析](#32017-冒泡排序的时间复杂度分析)
  - [3.3. 选择排序](#33-选择排序)
        - [3.3.0.1.8. 选择排序的时间复杂度](#33018-选择排序的时间复杂度)
  - [3.4. 插入排序](#34-插入排序)
        - [3.4.0.1.9. 插入排序时间复杂度](#34019-插入排序时间复杂度)
- [4. 高级排序](#4-高级排序)
  - [希尔排序](#希尔排序)
        - [希尔排序时间复杂度分析](#希尔排序时间复杂度分析)
  - [归并排序](#归并排序)
    - [递归](#递归)
    - [归并排序](#归并排序-1)
  - [快速排序](#快速排序)
    - [快速排序和归并排序的区别](#快速排序和归并排序的区别)
  - [排序的稳定性](#排序的稳定性)
      - [冒泡排序：稳定的](#冒泡排序稳定的)
      - [选择排序：每个位置选择当前最小元素进行交换，不稳定的](#选择排序每个位置选择当前最小元素进行交换不稳定的)
      - [插入排序：只有小于或大于才会交换位置](#插入排序只有小于或大于才会交换位置)
      - [希尔排序：不稳定](#希尔排序不稳定)
      - [归并排序：稳定排序](#归并排序稳定排序)
      - [快速排序：不稳定的](#快速排序不稳定的)
- [线性表](#线性表)
  - [顺序表](#顺序表)
    - [顺序表的遍历](#顺序表的遍历)
    - [顺序表的容量可变](#顺序表的容量可变)
    - [顺序表的时间复杂度](#顺序表的时间复杂度)
      - [java中ArrayList实现](#java中arraylist实现)
  - [链表](#链表)
    - [单向链表](#单向链表)
    - [双向链表](#双向链表)
      - [java中LinkedList实现](#java中linkedlist实现)
    - [链表的时间复杂度](#链表的时间复杂度)
      - [链表反转](#链表反转)
      - [快慢指针](#快慢指针)
      - [循环链表](#循环链表)
      - [约瑟夫问题](#约瑟夫问题)
- [栈](#栈)
      - [波兰表达式](#波兰表达式)
  - [队列 Queue](#队列-queue)
  - [符号表（链表实现）](#符号表链表实现)
  - [有序符号表](#有序符号表)
- [树](#树)
  - [是由n个有限节点组成具有层次关系的集合](#是由n个有限节点组成具有层次关系的集合)
  - [二叉树](#二叉树)
    - [满二叉树](#满二叉树)
    - [完全二叉树](#完全二叉树)
  - [二叉查找树（链表实现）](#二叉查找树链表实现)
    - [基础遍历-前中后遍历](#基础遍历-前中后遍历)
    - [层序遍历](#层序遍历)
- [堆，用树实现的结构](#堆用树实现的结构)
- [字典树](#字典树)
  - [树形数据结构](#树形数据结构)
  - [概念](#概念)

<!-- /TOC -->

# 1. 数据结构和算法概述
## 1.1. 数据结构
数据结构是研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。用来组织和存储数据
## 1.2. 数据结构分类
### 1.2.1. 逻辑结构
#### 1.2.1.1. 集合结构
数据元素除了属于同一个集合，没有任何关系
#### 1.2.1.2. 线性结构
数据元素之间存在一对一关系
#### 1.2.1.3. 树型结构
存在一对多的层次关系
#### 1.2.1.4. 图形结构
多对多关系
### 1.2.2. 物理结构
逻辑结构在计算机中的真正的表示方式
#### 1.2.2.1. 顺序结构
数据单元内存地址是连续的
* 好处：方便访问
* 坏处：插入、删除需要多个元素挪位，耗时
#### 1.2.2.2. 链式存储结构
存储单元可以是连续，也可以是不连续的
* 好处：插入、删除方便
## 1.3. 算法
根据一定条件，对一些数据进行计算，得到需要的结果
##### 1.3.0.2.1. 计算1到100的和
公式求解
##### 1.3.0.2.2. 计算10的阶乘
递归占用内存太大，直接for循环
# 2. 算法分析
## 2.1. 算法的时间复杂度分析
### 2.1.1. 事后分析方法
在算法执行前后定位，得到运行时间
### 2.1.2. 事前分析方法
根据统计方法进行估算，涉及到
* **算法采用的策略和方案**
* 编译产生的代码质量 x
* **问题的输入规模**
* 机器执行指令的速度 x
最重要的是把核心操作的次数和输入规模关联起来
### 2.1.3. 函数渐近增长
给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。
* 随着输入规模的增大，与最高次项相乘的常数可以忽略
* 算法函数中n最高次幂越小，算法效率越高
* 算法函数中的常数可以忽略
* 算法函数中最高次幂的常数因子可以忽略
* 算法函数中最高次幂越小，算法效率越高
### 2.1.4. 大O记法
程序执行次数=执行时间。
* 用常数1取代运行事件中所有加法常数
* 在修改后的运行次数中，只保留高阶项
* 如果高阶项存在，且常数因子不为1，则去除与这个项相乘的常数
#### 2.1.4.1. 常见的大O阶
##### 2.1.4.1.1. 线性阶
一般含有嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，时间复杂度为O(n)
##### 2.1.4.1.2. 平方阶
嵌套循环，时间复杂度极为O(n²)
##### 2.1.4.1.3. 立方阶
三层嵌套循环
##### 2.1.4.1.4. 对数阶
O(logn)，分析算法的增长率时与对数的底数无关
##### 2.1.4.1.5. 常数阶
O(1)
##### 2.1.4.1.6. 最坏的情况
最坏的情况是一种保证，在应用中，这是一种基本的保证，因此一般用最坏的情况作为时间复杂度分析
## 2.2. 算法的空间复杂度分析
* byte占用1个字节，short占用2个字节，int类型占用4个字节，long类型占用8个字节，float类型占用4个字节，double类型占用8个字节，boolean占用1个字节，char类型占用2个字节
* 计算机访问内存以字节读取，一个字节占用8bit
* 一个引用占用（机器地址）需要8个字节表示，例:Data data = new Data()，则data这个变量占用8个字节
* 创建一个对象，比如new Data()，除了Data对象内部存储的数据（例如年月日等信息）占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息
* 一般内存的使用，如果不够8个字节，都会被自动填充为8字节

    public class A{
        public int a=1;
    }
    整形成员变量a占用4个字节，对象本身占用16个字节，创建该对象需要20个字节，但由于不是以8为单位的，会自动填充为24字节
* java中数组被限定为对象，一般因为记录长度需要额外的内存，一般需要24字节的头信息，其中16个字节用来保存对象，4个字节保存长度，4个字节填充
* 一般不对空间复杂度进行估算（嵌入式开发除外），默认复杂度为时间复杂度
# 3. 简单排序
## 3.1. Comparable接口介绍
用来定义排序规则
实现方法
```java
// 首先在子对象中继承接口Comparable<子对象名称>，然后重写方法
public class Student implements Comparable<Student>{
@Override
  public int compareTo(Student o) {
      return this.age-o.age;
  }
// 然后在主程序中定义子函数调用接口对象，多态的形式，最后在主函数中使用子函数
Student s1 = new Student("张三",22);
Student s2 = new Student("李四",33);
public static Comparable getMax(Comparable c1,Comparable c2)
int result =c1.compareTo(c2);
return result>0?c1:c2;
```
## 3.2. 冒泡排序
比较相邻的两个数据，大的往后放，重复n-1+n-2+n=3...1次
冒泡API设计
|类名|Bubble|
|:--|:--|
|构造方法|Bubble()：创建对象|
|成员方法|1、public static void sort(Comparable[] a):对数组内的元素进行排序<br>2、private static boolean greater(Comparable v,Comparable w):判断v是否大于w<br>3、private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和j处的值|
##### 3.2.0.1.7. 冒泡排序的时间复杂度分析
在最坏情况下，逆序数组，每次比较都需要交换数据
元素比较的次数：(N-1)+(N-2)...1
元素交换的次数与上一样
总执行次数为O(N²)
## 3.3. 选择排序
* 每次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值进行比较，如果当前索引处的值大于其他某个元素中的值，则重新假定为最小值，最后找到最小值所在索引
* 交换第一个索引处和最小值所在的索引处的值
|类名|Selection|
|:--|:--|
|构造方法|Selection():创建Selection对象|
|成员方法|1、public static void sort(Comparable[] a):对数组内的元素进行排序<br>2、private static boolean greater(comparable v,Comparable w):判断v是否大于w<br>3、private static void ecxh(Comparable[] a,int i,int j)|
##### 3.3.0.1.8. 选择排序的时间复杂度
元素比较次数：N^2/2-N/2
元素交换次数：N-1
时间复杂度为O(N²)
## 3.4. 插入排序
* 把所有元素分为两组，已排序和未排序
* 找到未排序中的第一个数，向已经排序的组中插入
* 倒叙遍历已经排序的元素，依次将待插入元素进行比较，直到找到一个元素小于等于待插入元素
|类名|Insertion|
|:--|:--|
|构造方法|Insertion():创建Insertion对象|
|成员方法|1、public static void sort(Comparable[] a):对数组内元素进行排序<br>2、private static boolean greater(Comparable v,Comparable w):判断v还是w大<br>3、private static void exch(Comparable[] a,int i,int j):交换a数组中i索引和j索引处的值|
##### 3.4.0.1.9. 插入排序时间复杂度
最坏情况
比较的次数：N²/2-N/2
交换的次数：N²/2-N/2
时间复杂度为O(N²)
# 4. 高级排序
## 希尔排序
是插入排序的一种，又称缩小增量排序
排序原理
* 1、选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组
* 2、对分好组的每一组数据完成插入排序
* 3、较小增长量，最小减为1，重复第二步操作
插入效率分析：在增长量较大时每次比较都能将小的数交换一个大的步长，而不是一次一交换
增长量h的值采用以下规则
int h=1
while(h<arr.length){
  h = 2*h+1;
}
减小的规则
h = h/2
|类名|Shell()|
|:--|:--|
|构造方法|Merge():创建Merge对象|
|成员方法|1、public static void sort(Comparable[] a):对数组内元素进行排序<br>2、private  static void sort(Comparable[] a,int lo,int hi)：对数组内指定索引内的数进行排序<br>3、private static void merge(Comparable[] a,int lo,int mid,int hi)：将数组a[]索引lo和hi内的两个数组lo-Mid和mid+1-hi进行排序拼接<br>4、less|
|成员变量|private static Comparable[] assist：用来临时存储用来排序拼接的数组|
##### 希尔排序时间复杂度分析
插入排序时间：34311
希尔排序时间：20
## 归并排序
### 递归
定义方法时，在方法内部调用其本身
注意事项：递归调用时层级不能太深，否则会出现栈内存异常
### 归并排序
1、尽可能的一组数据拆分成两个元素相等的子组，并对每个子组继续拆分，直到拆分后的每个子组元素个数是1为止
2、将相邻的两个子组进行合并成一个有序的大组
3、不断地重复步骤2，直到最终只有一个组为止
时间复杂度：O(nlog(n))
缺点：需要申请额外的空间，典型的空间换时间
## 快速排序
通过一趟将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
* 首先设定一个分界值，通过该分界值将数组分成左右两部分
* 将大于或等于分界值的数据放到数组右边，小于分界值的数据放到数组左边，此时左边部分中各元素都小于或等于分界值，而右边部分中个元素都大于或等于分界值
* 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值，右侧的数组数据也可以做类似处理
* 重复上述处理，这是一个递归定义，通过递归将左侧部分排好序后，再递归排好右侧部分的顺序，当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了
|类名|Shell()|
|:--|:--|
|构造方法||
|成员变量||
### 快速排序和归并排序的区别
快速排序是另一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的，归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。再归并排序中，一个数组被等分成两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后
最好情况，取得分界值在中间，即时间复杂度为O(nlogn)
最坏情况，时间复杂度为O(N²)
平均情况，时间复杂度为O(NlogN)
## 排序的稳定性
数组中有若干元素，其中元素A和元素B相等，并且A元素在B元素前面。如果使用某些排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个算法是稳定的。
意义：多次排序，使对象排序后不需要交换位置，占用内存
#### 冒泡排序：稳定的
#### 选择排序：每个位置选择当前最小元素进行交换，不稳定的
#### 插入排序：只有小于或大于才会交换位置
#### 希尔排序：不稳定
#### 归并排序：稳定排序
#### 快速排序：不稳定的
# 线性表
前驱元素：若A元素在B元素的前面，则称A为B的前驱元素
后驱元素：若B元素在A元素的后面，则称B为A的后继元素
* 线性表的特征：
* * 元素之间具有一对一的逻辑关系
* * 第一个数据元素没有前驱，这个数据元素被称为头结点
* * 第二个数据元素没有后继，这个数据元素被称为尾结点
* * 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后驱
* 线性表的分类
* * 线性表中数据存储的方式可以是**顺序存储**，也可以是**链式存储**，按照数据存储方式不同，可以把线性表分为**顺序表**和**链表**
## 顺序表
顺序表的实现，以数组的形式实现
|类名|SequenceList<T>|
|:--|:--|
|构造方法|SequenceList(int capacity):创建容量为capacity的SequenceList对象|
### 顺序表的遍历
在java中，遍历集合的方式一般都是用的foreach循环，如果想让我们的SequenceList也能支持foreach循环，则需要做如下操作：
* 让SequenceList内部实现iterable接口，重写iterable方法
* 让SequenceList内部提供一个内部类SIterator实现Iterator接口，重写hasNext()方法和next()方法
### 顺序表的容量可变
分析：什么时候需要扩容
* 添加元素
* * 如果不能容纳，创建一个是原数组两倍容量的新数组来存储元素
* 移除元素（缩容）
* * 如果发现数据元素的数量不及数组容量的1/4，则创建一个是原数组容量1/2的新数组来存储元素
### 顺序表的时间复杂度
get(i):eles[i]即可得到，所以时间复杂度为O(1)
insert(int i,T t):每一次插入，都需要把位置后面的元素移动一次，时间复杂度为O(n)
remove:时间复杂度为O(n)
由于顺序表的底层由数组实现，涉及到容器扩容，因此在某些需要扩容的节点，耗时会突增，尤其是元素较多时更为明显
#### java中ArrayList实现
* 是否使用数组实现
* * transient Object[] elementData;
* 有没有扩容操作
* * 有，使用grow方法，内部通过newCapacity返回新数组
* 有没有遍历方法
* * private class Itr implements Iterator<E>
* * 其中有next方法和hasNext方法
* 因为考虑了各方因素，具有通用性，针对性差
## 链表
### 单向链表
* 只能前进
### 双向链表
* 每一个结点都包含两个指针，其中一个指针同来指向前驱结点，一个指针用来指向后继结点
* 第一个结点的头结点为空，且不存储数据，data也为空
* 最后一个结点指向下一个结点的指针为空
* 优点：能够找到前一个结点，可进可退

#### java中LinkedList实现
* 节点是有双指针，底层是由双向链表实现的
### 链表的时间复杂度
get(i)：时间复杂度为O(n)
insert(i,t)：时间复杂度为O(n)
remove(i)：时间复杂度为O(n)
* 相比顺序表，链表插入和删除的时间复杂度一样，但因链表的地址是不连续的，不需要定义容器大小，不需要指定内存地址
* 如果查询操作多，用顺序表；如果增删操作多，用链表


#### 链表反转
#### 快慢指针
* 利用.nexx和.next.next得到中位字符串
* 有环指针，快慢指针会相遇；无环指针，快慢指针不会相遇
#### 循环链表
最后一个节点指向第一个节点
#### 约瑟夫问题
# 栈
栈是一种基于先进后出（FILO）的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。压栈、弹栈
#### 波兰表达式
中缀表达式与逆波兰表达式
a+b----ab+
a+(b+c)----abc+
a+(b-c)*d---abc-d*+
两个数字+符号进行运算，从左边第一个符号位开始算
## 队列 Queue

## 符号表（链表实现）

## 有序符号表


# 树
符号表的增删，随着元素个数N的增多，其耗时也是线性增多的，时间复杂度为O(n)，为了提高运算效率，学习树。
## 是由n个有限节点组成具有层次关系的集合
* 特点
* * 每个结点有0个或多个子结点
* * 没有父节点的节点为根结点
* * 每一个非根结点只有一个父结点
* * 每个结点及其后代结点整体上是一棵树，称为当前结点的父节点的一个子树
* 结点的度：一个结点含有子树的个数称为该结点的子树
* 叶结点：度为0的结点称为叶结点，即终端节点
* 分支节点：度不为0的结点
* 结点的层次：从根结点开始，根节点的层次为1，根的直接后继层次为2，以此类推
* 结点的层序编号：将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把它们编成连续的自然数
* 树的度：树中左右结点的度的最大值
* 树的高度：最大的结点层次
* 森林：把互不相交的树的集合
* 孩子结点：一个结点的直接后继结点称为该结点的孩子结点
* 父节点：一个结点的直接前驱称为该点的父节点
* 兄弟结点：同一父结点的孩子结点间称为兄弟结点
## 二叉树
度不超过2的树（每个结点最多有两个子节点）
### 满二叉树
如果每一层的结点树都达到最大值，则这个二叉树就是满二叉树（2^k-1,k为层数)
### 完全二叉树
叶结点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最**左边**的若干位置的二叉树
## 二叉查找树（链表实现）
二叉树结点：Node(key,value,left,right)
二叉查找树：BinaryTree<key extends Comparable<key>,Value value>//需要根据键进行排序
### 基础遍历-前中后遍历
### 层序遍历
队列的思想，节点左右弹入弹出，先进先出

# 堆，用树实现的结构
* 是完全二叉树，每一层从左往右都是满的，只有最后一侧
* 一般底层用数组实行
* 通常使用数组实现
* 如果一个结点的位置为k，则父节点的位置为k/2,而他的子节点位置分别为2*k和2*k+1
* 每个结点都大于等于它的两个子节点，子节点不需要排序











# 字典树
List:
Map与Set基本等价 HashSet
Quene：队列，先入先出  Stack 栈：后进先出，duene
Tree:二叉树，索引树，红黑树，Btree,B+tree,字典树，哈夫曼树

查找：在某些情况下高于哈希表

## 树形数据结构
是一类高级非线性数据结构，其中最重要的是树和二叉树。其特殊的层次结构在计算机中扮演了非常重要的地位，其一些重要的算法和高性能的系统几乎采用了树型结构
Btree、字典树、红黑树
* 有一个根节点，一般称为root节点
* 每一个元素都被称为node
* 除了root节点外，其他的节点都被分成n个互不相交的集合
节点：
叶子节点：
子树：递归，子节点作为根节点
深度：
度：跟深度不是一个东西，度是树的叉
森林：多个树的集合
## 概念
字典树又称为单词查找树，哈希树的变种，常用于统计，查找搜索引擎中用于分词，词频统计（DF/IDF），自动补全机制等
查找效率高，其核心思想是利用公共前缀来减少时间
