<!-- TOC -->

- [1. 前置教程](#1-前置教程)
  - [1.1. JDK的安装目录](#11-jdk的安装目录)
- [2. 基础语法](#2-基础语法)
  - [2.1. 注释](#21-注释)
  - [2.2. 关键字](#22-关键字)
  - [2.3. 常量](#23-常量)
  - [2.4. 数据类型](#24-数据类型)
  - [2.5. 变量](#25-变量)
  - [2.6. 标识符](#26-标识符)
  - [2.7. 类型转换](#27-类型转换)
    - [2.7.1. 自动类型转换](#271-自动类型转换)
    - [2.7.2. 强制类型转换](#272-强制类型转换)
- [3. 运算符](#3-运算符)
  - [3.1. 算数运算符](#31-算数运算符)
    - [3.1.1. 字符”+“操作](#311-字符操作)
    - [3.1.2. 字符串“+”操作](#312-字符串操作)
  - [3.2. 赋值运算符](#32-赋值运算符)
  - [3.3. 自增、自减运算符](#33-自增自减运算符)
  - [3.4. 关系运算符](#34-关系运算符)
  - [3.5. 逻辑运算符](#35-逻辑运算符)
  - [3.6. 短路逻辑运算符](#36-短路逻辑运算符)
  - [3.7. 三元运算符](#37-三元运算符)
  - [3.8. 案例](#38-案例)
- [4. 数据输入](#4-数据输入)
- [5. 流程控制](#5-流程控制)
  - [5.1. if-else语句](#51-if-else语句)
  - [5.2. if-elseif-else语句](#52-if-elseif-else语句)
  - [5.3. switch 语句](#53-switch-语句)
  - [5.4. for循环语句](#54-for循环语句)
    - [5.4.1. for循环语句格式](#541-for循环语句格式)
  - [5.5. while循环语句](#55-while循环语句)
  - [5.6. do...while循环语句](#56-dowhile循环语句)
  - [5.7. 跳转控制语句](#57-跳转控制语句)
  - [5.8. 循环嵌套](#58-循环嵌套)
  - [5.9. Random](#59-random)
- [6. IDEA](#6-idea)
  - [6.1. IDEA中项目结构](#61-idea中项目结构)
  - [6.2. IDEA中内容辅助键和快捷键](#62-idea中内容辅助键和快捷键)
    - [6.2.1. 快速生成语句](#621-快速生成语句)
    - [6.2.2. 内容辅助键](#622-内容辅助键)
    - [6.2.3. 注释](#623-注释)
    - [6.2.4. 格式化](#624-格式化)
  - [6.3. IDEA中新建模块|删除模块|导入模块](#63-idea中新建模块删除模块导入模块)
- [7. 数组](#7-数组)
  - [7.1. 数组定义格式](#71-数组定义格式)
  - [7.2. 数组初始化之动态初始化](#72-数组初始化之动态初始化)
    - [7.2.1. 动态初始化](#721-动态初始化)
    - [7.2.2. 静态初始化](#722-静态初始化)
  - [7.3. 数组元素访问](#73-数组元素访问)
  - [7.4. java中内存分配](#74-java中内存分配)
      - [7.4.0.1. 堆内存](#7401-堆内存)
  - [7.5. 数组中两个常见小问题](#75-数组中两个常见小问题)
  - [7.6. 数组常见操作](#76-数组常见操作)
    - [7.6.1. 遍历](#761-遍历)
    - [7.6.2. 获取最值(排序|变量存储最大值)](#762-获取最值排序变量存储最大值)
- [8. 方法](#8-方法)
  - [8.1. 概述](#81-概述)
  - [8.2. 方法定义](#82-方法定义)
  - [8.3. 方法注意事项](#83-方法注意事项)
  - [8.4. 方法重载](#84-方法重载)
  - [8.5. 方法参数传递](#85-方法参数传递)
  - [8.6. ps:print(ln)](#86-psprintln)
- [9. Debug](#9-debug)
- [10. 类和对象](#10-类和对象)
      - [10.0.0.1. 类：手机（现实生活中一类具有共同属性和行为的事物的抽象）](#10001-类手机现实生活中一类具有共同属性和行为的事物的抽象)
  - [10.1. 类的定义](#101-类的定义)
  - [10.2. 对象的使用](#102-对象的使用)
  - [10.3. private关键字](#103-private关键字)
  - [10.4. this关键字](#104-this关键字)
  - [10.5. this内存原理](#105-this内存原理)
  - [10.6. 封装](#106-封装)
  - [10.7. 构造方法](#107-构造方法)
    - [10.7.1. 注意事项](#1071-注意事项)
  - [10.8. 标准类制作](#108-标准类制作)
- [11. API](#11-api)
  - [11.1. String](#111-string)
    - [11.1.1. String构造方法](#1111-string构造方法)
    - [11.1.2. 字符串的比较](#1112-字符串的比较)
  - [11.2. StringBulider](#112-stringbulider)
    - [11.2.1. StringBulider类的创建](#1121-stringbulider类的创建)
    - [11.2.2. StringBuilder类的添加和反转](#1122-stringbuilder类的添加和反转)
  - [11.3. StringBulider和String相互转换](#113-stringbulider和string相互转换)
- [12. 集合](#12-集合)
  - [集合基础](#集合基础)
    - [ArrayList构造方法和添加方法](#arraylist构造方法和添加方法)
    - [ArrayList集合常用方法](#arraylist集合常用方法)
  - [小作业，设计一个学生管理系统](#小作业设计一个学生管理系统)
- [继承](#继承)

<!-- /TOC -->
# 1. 前置教程
## 1.1. JDK的安装目录
&nbsp;&nbsp;目录名称&nbsp;&nbsp;说明
1. bin&nbsp;该路径下存放了JDK的各种工具命令。**javac**和**jav**就放在这个目录
2. conf&nbsp;该路径下存放了JDK的相关配置
3. include&nbsp;该路径下存放了一些平台特定的头文件
4. jmods&nbsp;该路径存放了JDK各种模块
5. legal&nbsp;该路径存放了JDK各种模块的授权文档
6. lib&nbsp;该路径存放了JDK工具的一些补充JAR包
# 2. 基础语法
## 2.1. 注释
```java
//单行注释
/* 多行
           注释
 */
```
## 2.2. 关键字
被java语言赋予了特别含义的单词，如public，class，void等
关键字的字母全部小写
## 2.3. 常量
1. 字符串常量：用**双引号**的内容
2. 整数常量
3. 小数常量
4. 字符常量：用**单引号**的内容
5. 布尔值和空值null
## 2.4. 数据类型
最小信息单元：位(bit)，最小存储单元：字节(Byte|B)
1. 基本数据类型
   1. 数值型
      1. 整数(byte 128,short 32768,long 2^63)
      2. 浮点数(float E38,double E308)
      3. 字符(char 65535)
   2. 非数值型
      1. 布尔(boolean)
2. 引用数据类型
   1. 类(class)
   2. 接口(interface)
   3. 数组([])
## 2.5. 变量
变量是内存中的一小块区域
强类型语言：变量名、数据类型、变量值
变量使用事项：
1. 一个方法内一个变量名最多只能定义一次
2. 定义变量时需要赋值，且在long和float赋值时要加L和F，因为整形默认值为int，浮点型默认值为double。
## 2.6. 标识符
概念
1. 由数字、字母、下划线(_)及美元符($)组成
2. 不能以数字开头
3. 不能是关键字
4. 区分大小写
约定
小驼峰命名法：方法，变量
1. 标识符是一个单词的时候，首字母小写
2. 标识符由多个单词组成时，第一个单词首字母小写，其他单词首字母大写
大驼峰命名法：类
1. 标识符是一个单词的时候，首字母大写
2. 标识符由多个单词组成的时候，每个单词首字母大写
## 2.7. 类型转换
### 2.7.1. 自动类型转换
double d = 10;
![](自动类型转换.png)
### 2.7.2. 强制类型转换
把一个表示数据范围大的数值或变量赋值给另一个表示数据范围小的变量，一般不使用
int k = (int)88.88;
# 3. 运算符
## 3.1. 算数运算符
**(+ - * /(商,准确商，小数与除数与被除数中最多小数位的数据类型一致) %(余数))**
### 3.1.1. 字符”+“操作
算术表达式中包含多个基本数据类型的时候，整个算术表达式的类型会自动进行提升。等级顺序为byte,short,char->int->long->float->double
char i,c;正确相加结果为：int j = i + c
### 3.1.2. 字符串“+”操作
"it " + "is" = "it is"
666 + "it" = "666it"
"黑马“ + 66 + 4 = “黑马664”
66 + 4 + ”黑马“ = ”70黑马“
字符串中含有数字时，显示和运算从左到右进行，可用括号提升优先级
## 3.2. 赋值运算符
“+=”等运算符隐含了强制类型转换
"-="、"*="、"/="、"%="
```java
int i = 10;
i += 10;//+=的操作包含了强制类型转换
short s = 10;
s = short(s + 10);//需要变换成short类型
```
## 3.3. 自增、自减运算符
i++/++i等价于i = i + 1;    i--
参与操作使用：
int j = i++;
++放在变量后面，则首先赋值，再执行++，反之则先执行++再赋值
## 3.4. 关系运算符
==,!=,>,<,<=,>=
int和float可以进行比较
## 3.5. 逻辑运算符
与   &   
或  |  
异或    ^  
非   ！
## 3.6. 短路逻辑运算符
&&   ||
区别：
```java
int i = 10;
int j = 20;
(i++ > 100) && (j++ > 100);
//此时因为i++>100为假，当使用短路逻辑与运算符时便不再继续运行，i和j最终值为11，20，及j++不再执行
```
短路逻辑运算遵从从左到右运算，当达到终结条件时右边的关系式不再进一步运算
## 3.7. 三元运算符
格式：关系表达式？表达式1：表达式2
a>b?x:y;
计算关系表达式的值，如果为真，则表达式1就是运算结果，否则表达式2为运算结果
## 3.8. 案例
三个数最大值
```java
int a = 150;
int b = 210;
int c = 165;
int max = (a>b?a:b)>c?(a>b?a:b):c;;
```
# 4. 数据输入
```java
import java.util.Scanner
Scanner sc = new Scanner(System.in);
int x = sc.nextInt();
int y = sc.nextInt();
System.out.println("x:" + x);
```
# 5. 流程控制
顺序语句、分支语句、循环语句
## 5.1. if-else语句
```java
if(关系表达式){
    语句体1;
}else{
    语句体2;
}
```
## 5.2. if-elseif-else语句
```java
if(关系表达式1){
    yuju1;
}else if{
    yuju2;
}else{
    yuju3'
}
```
## 5.3. switch 语句
注意switch中每个case都要求有个break;否则会出现case穿透，导致顺序运行case直到遇到break时停止
```java
switch(表达式){
    case 值1:
        yujuti1;
        break;
    case 值2:
        yujti2;
        break;
    case 值3:
        yujuti3;
        break;
    default:
        yujuti4;//因为default在最后，可以不要break
}
//简化版
swicth(表达式){
    case 1:case 2:case 3:
        yujuti1;
        break;
    case 4:case
}
```
## 5.4. for循环语句
### 5.4.1. for循环语句格式
for循环中的变量i,j,k这些只能在循环内部使用
```java
for (初始化条件;条件判断句;条件控制句){
    循环体语句;
}
for循环死循环格式：
for(;;){
    循环体语句
}//ctrl+c结束死循环
```
## 5.5. while循环语句
while语句的变量因为定义在循环体外部，所以能在循环结束后再循环外部使用
```java
基本格式：
while(条件判断){
    循环体语句;
}  

完整格式：
初始化语句;
while(条件判断语句){
    循环体语句;
    条件控制语句;
}

死循环格式：
while(true){
    循环体语句
}//ctrl+c结束死循环
```
## 5.6. do...while循环语句
至少会执行一次循环体
```java
基本格式
do {
    循环体语句;
}while(条件判断语句);  

完整格式
初始化语句；
do{
    循环体语句;
    条件控制语句;
}while(条件判断句);
```
## 5.7. 跳转控制语句
跳过某次循环体内容：continue  
结束循环体运行：break
## 5.8. 循环嵌套
不同|相同循环嵌套
## 5.9. Random
```java
导包:import java.util.Random;  
创建对象:Random r = new Random();  
获取随机数:int number = r.nextInt(10);//获取的数据范围[0,10)，包括0不包括10
```
# 6. IDEA
## 6.1. IDEA中项目结构
项目以下很多模块，模块中有很多包，包下有很多java文件
## 6.2. IDEA中内容辅助键和快捷键
### 6.2.1. 快速生成语句
快速生成main()方法：psvm，回车  
快速生成输出语句：sout，回车
### 6.2.2. 内容辅助键
Ctrl+Alt+space(内容补全、内容提示等)
### 6.2.3. 注释
单行注释：Ctrl+/
多行注释：Ctrl+Shift+/
### 6.2.4. 格式化
格式化的是将代码格式成标准格式
Ctrl+Alt+L
## 6.3. IDEA中新建模块|删除模块|导入模块
# 7. 数组
用于存储多个相同数据类型的数据
## 7.1. 数组定义格式
```java
格式1：（推荐）
int[] arr
定义了一个int类型的数组，数组名是arr  
格式2：
int arr[]
定义了一个int型的变量，变量名是arr数组
```
## 7.2. 数组初始化之动态初始化
### 7.2.1. 动态初始化
初始化时只指定数组长度，由系统为数组分配初始值
```java
int[] arr = new int[3];//生成的数组元素都为0
左边：
    int:说明数组中的元素类型是int
    []:说明是一个数组
    arr:数组名称
右边：
    new:为数组申请内存空间
    int:说明数组中的元素类型是int
    []:说明这是一个数组
    3:数组长度
```
### 7.2.2. 静态初始化
int[] arr={1,2,3};
## 7.3. 数组元素访问
数组名[索引]，从0开始的编号  
arr:数组名，空间地址  
arr[0],arr[1],arr[2]  
## 7.4. java中内存分配
int[] arr = new int[3];  
首先new int[3]申请一个长度为3的数组，地址名为mmm1，这个内存称为堆内存  
#### 7.4.0.1. 堆内存
存储new出来的内容，数组在初始化时，会为存储空间添加默认值，每一个new出来的东西都有一个地址值是，使用完毕后被回收

然后将int[]类型的arr变量指向该内存地址，故直接打印arr输出为mmm1，变量arr成为栈内存，定义在方法中的变量，使用完毕，立即消失
而arr[0]即指向内存后的第一个元素值，即数据
```java
int[] arr2 = arr;//赋值的为地址，结果为两个数组堆内存地址相同
```
## 7.5. 数组中两个常见小问题
* 防止索引不存在造成索引越界
* 防止将栈内存指向null空值
## 7.6. 数组常见操作
### 7.6.1. 遍历
用循环进行遍历，获取元素个数：arr.length，注意元素个数遍历时应减1。
```java
for (int i=0;i<arr.length;i++){

}
```
### 7.6.2. 获取最值(排序|变量存储最大值)
# 8. 方法
## 8.1. 概述
方法是将具有独立功能的代码块组织成一个整体，使其具有特殊功能的代码集
* 方法必须先创建才可以使用，该过程成为方法定义
* 方法创建后并不是直接运行的，需要手动使用后才能执行，该过程成为方法调用

## 8.2. 方法定义
```java
public static 数据类型(一般void) 方法名(){
    //方法体
}
```
## 8.3. 方法注意事项
* 方法不能嵌套，方法之间是独立的
* void表示无返回值，可以省略return ，也可以单独的书写return，后面不加数据

## 8.4. 方法重载
指同一个类中定义的多个方法之间的关系，满足以下条件的多个方法相互构成重载
* 多个方法在同一个类中
* 多个方法方法名相同
* 多个方法参数不相同，类型不同或数量不同  
特点：  
* 重载仅对应方法的定义，与方法的调用无关，调用方式参考标准格式
* 重载仅针对同一个类中方法的名称与参数进行识别，与**返回值**无关，即不能通过返回值来判定两个方法是否相互重载

## 8.5. 方法参数传递 
方法中参数不影响方法外参数
数组传入方法时因为传递的是地址，所以在方法中改变数组数据时方法外也会改变
## 8.6. ps:print(ln)
* System.out.println();//输出内容并换行，单独使用可起到换行作用
* System.out.print();//输出内容不换行
# 9. Debug
idea有自动导包，不需要手动导包
# 10. 类和对象
new对象  
类：对现实生活中一类具有共同属性和行为的事物的抽象
特点
* 类时对象的数据类型
* 类是具有相同属性和行为的一组对象的集合  

属性：对象具有的各种特征，每个对象的每个属性都拥有特定的值  
行为：对象能够执行的操作  
#### 10.0.0.1. 类：手机（现实生活中一类具有共同属性和行为的事物的抽象）
属性：品牌、价格
行为：打电话，发短信
## 10.1. 类的定义
类是Java程序的基本组成单位  
**类**=**属性（成员变量）**+**行为（成员方法，去点static关键字）**  
## 10.2. 对象的使用
成员变量：类中方法外的变量，在堆内存，随着对象的存在而存在，对象消失则消失，**有默认的初始化值**
局部变量：方法中的变量，在栈内存，方法使用后即消失，**没有默认初始值，必须先定义赋值**
```java
Phone p = new Phone();
//使用成员变量
p.brand
//使用成员方法
p.call()
```
## 10.3. private关键字
private关键字：权限修饰符，可以修饰成员，保护成员不被别的成员使用，被**private**修饰的成员只能在本类中才能访问  
针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作：
* 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰
* 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰
## 10.4. this关键字
* 用来指代变量名称  ，解决局部变量隐藏成员变量
* 方法被哪个对象调用，this就代表哪个对象，如调用对象s1中的方法，此时this等价于s1。其指向类本身
* 用 this.name 修饰name时，this.name 指的是**成员变量**，而name指的是局部变量  
* 当方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量
## 10.5. this内存原理
与数组、类-成员原理相似
## 10.6. 封装
**面向对象三大特征：封装、继承、多态**
封装时面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的
封装原则：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的fetXxx()/setXxx()方法
## 10.7. 构造方法
构造方法是一种特殊方法，作用是创建对象，完成对象数据的初始化
```java
public Student(){}//无参构造方法
public Student(String name){
        this.name = name;
        System.out.println("name");
    }
public Student(int age){
        this.age = age;
        System.out.println("age");
    }

Student s1 = new Student();
Student s2 = new Student("林青霞");
Student s3 = new Student(12)
```
### 10.7.1. 注意事项
* 当一个类中没有构造方法时，系统会给出一个默认的无参构造方法
* 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法
* **推荐无论是否使用构造方法，都手写无参数构造方法**
## 10.8. 标准类制作
# 11. API
* 调用方法时，如果方法有明确的返回值，我们用变量接收可以手动完成，也可以使用快捷键的方式完成Ctrl+Alt+V

## 11.1. String
字符串不变，它们的值在创建后是无法更改的，但可以被共享。
字符串效果上相当于字符串组(char[ ])，但是底层原理是字节数组(byte[ ])  
### 11.1.1. String构造方法
|方法名|说明|
|:--|:--|
|public String()|创建一个空白字符串对象，不含有任何内容|
|public String(char[] chs)|根据字符数组的内容来创建字符串对象|
|public String(byte[] bys)|根据字节数组的内容，来创建字符串对象|
|String s = "abc";|直接赋值的方式创建字符串对象，内容就是abc|  

"abc"这种常量池的地址相同，而通过new String("abc")创建的两个字符串对象指向的是String对象的地址，此时两者地址不同
### 11.1.2. 字符串的比较
|符号|作用|
|:--|:--|
|==|基本类型：比较的是数据值是否相同<br>引用类型：比较的是地址值是否相同</br>|
|equals()|s1.equals(s2);比较字符串内容|

* 数组长度：数组名.length
* 字符串长度：字符串对象.length()
* 字符串获取某个位置的字符：字符串.charAt(int index)
* 判断字符串是大小写、数字、符号等只需要对ch限定范围即可，如ch>='A' && ch<='Z'

## 11.2. StringBulider
```java
String s = "hello";
s += "world";
```
此时"hello","world","helloworld"都会占用空间，造成浪费，而StringBulider类就能解决改问题。  
该类为可变的字符串
### 11.2.1. StringBulider类的创建
```java
StringBuilder sb2 = new StringBuilder("hello");
```
### 11.2.2. StringBuilder类的添加和反转
```java
sb2.append("world").append("   ").append("hahha");//链式调用
sb2.reverse();//反转
```
## 11.3. StringBulider和String相互转换
```java
StringBuilder sb2 = new StringBuilder("hello");
String s2 = sb2.toString();
StringBuilder s3 = new StringBuilder(s2);
```
# 12. 集合
提供一种存储空间可变的数据类型  
ArrayList，可调整大小的数组实现  
它是一种特殊的数据类型，泛型

## 集合基础
### ArrayList构造方法和添加方法
```java
ArrayList<String> array = new ArrayList<>();
array.add("world");//返回值为boolean类型，表示添加是否成功
array.add(2,"javase");//指定位置处添加，注意不要超过最大索引位置+1
```
### ArrayList集合常用方法
修改是array.set(index,类);
```java
ArrayList<String> array = new ArrayList<>();
    array.add("n1");//添加
    array.add("n2");
    array.add("n3");
    array.add("n4");
    System.out.println(array);
    array.remove(2);//根据索引删除，当没有该元素时返回false
    System.out.println(array);
    array.remove("n1");//根据元素删除
    System.out.println(array);
    System.out.println(set(1,"javase"));//【**修改**】指定位置的元素
    System.out.println(array.get(0));//得到索引处元素数据
    System.out.println(array.size());//得到array元素个数
```
## 小作业，设计一个学生管理系统
* 快捷键Alt+Insert能够自动生成构造函数及get/set方法，根据自己需要进行选择
* System.exit(0);//退出程序
* \t是tab键的意思，作用是进行缩进

```java
switch (line){
  case "1":
    bulabula;
    break;
  case "2":
    bulabula;
    break;
  default:
    bulabula;
}
```
# 继承