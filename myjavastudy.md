<!-- TOC -->

- [1. 前置教程](#1-前置教程)
  - [1.1. JDK的安装目录](#11-jdk的安装目录)
- [2. 基础语法](#2-基础语法)
  - [2.1. 注释](#21-注释)
  - [2.2. 关键字](#22-关键字)
  - [2.3. 常量](#23-常量)
  - [2.4. 数据类型](#24-数据类型)
  - [2.5. 变量](#25-变量)
  - [2.6. 标识符](#26-标识符)
  - [2.7. 类型转换](#27-类型转换)
    - [2.7.1. 自动类型转换](#271-自动类型转换)
    - [2.7.2. 强制类型转换](#272-强制类型转换)
- [3. 运算符](#3-运算符)
  - [3.1. 算数运算符](#31-算数运算符)
    - [3.1.1. 字符”+“操作](#311-字符操作)
    - [3.1.2. 字符串“+”操作](#312-字符串操作)
  - [3.2. 赋值运算符](#32-赋值运算符)
  - [3.3. 自增、自减运算符](#33-自增自减运算符)
  - [3.4. 关系运算符](#34-关系运算符)
  - [3.5. 逻辑运算符](#35-逻辑运算符)
  - [3.6. 短路逻辑运算符](#36-短路逻辑运算符)
  - [3.7. 三元运算符](#37-三元运算符)
  - [3.8. 案例](#38-案例)
- [4. 数据输入](#4-数据输入)
- [5. 流程控制](#5-流程控制)
  - [5.1. if-else语句](#51-if-else语句)
  - [5.2. if-elseif-else语句](#52-if-elseif-else语句)
  - [5.3. switch 语句](#53-switch-语句)
  - [5.4. for循环语句](#54-for循环语句)
    - [5.4.1. for循环语句格式](#541-for循环语句格式)
  - [5.5. while循环语句](#55-while循环语句)
  - [5.6. do...while循环语句](#56-dowhile循环语句)
  - [5.7. 跳转控制语句](#57-跳转控制语句)
  - [5.8. 循环嵌套](#58-循环嵌套)
  - [5.9. Random](#59-random)
- [6. IDEA](#6-idea)
  - [6.1. IDEA中项目结构](#61-idea中项目结构)
  - [6.2. IDEA中内容辅助键和快捷键](#62-idea中内容辅助键和快捷键)
    - [6.2.1. 快速生成语句](#621-快速生成语句)
    - [6.2.2. 内容辅助键](#622-内容辅助键)
    - [6.2.3. 注释](#623-注释)
    - [6.2.4. 格式化](#624-格式化)
  - [6.3. IDEA中新建模块|删除模块|导入模块](#63-idea中新建模块删除模块导入模块)
- [7. 数组](#7-数组)
  - [7.1. 数组定义格式](#71-数组定义格式)
  - [7.2. 数组初始化之动态初始化](#72-数组初始化之动态初始化)
    - [7.2.1. 动态初始化](#721-动态初始化)
    - [7.2.2. 静态初始化](#722-静态初始化)
  - [7.3. 数组元素访问](#73-数组元素访问)
  - [7.4. java中内存分配](#74-java中内存分配)
      - [7.4.0.1. 堆内存](#7401-堆内存)
  - [7.5. 数组中两个常见小问题](#75-数组中两个常见小问题)
  - [7.6. 数组常见操作](#76-数组常见操作)
    - [7.6.1. 遍历](#761-遍历)
    - [7.6.2. 获取最值(排序|变量存储最大值)](#762-获取最值排序变量存储最大值)
- [8. 方法](#8-方法)
  - [8.1. 概述](#81-概述)
  - [8.2. 方法定义](#82-方法定义)
  - [8.3. 方法注意事项](#83-方法注意事项)
  - [8.4. 方法重载](#84-方法重载)
  - [8.5. 方法参数传递](#85-方法参数传递)
  - [8.6. ps:print(ln)](#86-psprintln)
- [9. Debug](#9-debug)
- [10. 类和对象](#10-类和对象)
      - [10.0.0.1. 类：手机（现实生活中一类具有共同属性和行为的事物的抽象）](#10001-类手机现实生活中一类具有共同属性和行为的事物的抽象)
  - [10.1. 类的定义](#101-类的定义)
  - [10.2. 对象的使用](#102-对象的使用)
  - [10.3. private关键字](#103-private关键字)
  - [10.4. this关键字](#104-this关键字)
  - [10.5. this内存原理](#105-this内存原理)
  - [10.6. 封装](#106-封装)
  - [10.7. 构造方法](#107-构造方法)
    - [10.7.1. 注意事项](#1071-注意事项)
  - [10.8. 标准类制作](#108-标准类制作)
- [11. API](#11-api)
  - [11.1. String](#111-string)
    - [11.1.1. String构造方法](#1111-string构造方法)
    - [11.1.2. 字符串的比较](#1112-字符串的比较)
  - [11.2. StringBulider](#112-stringbulider)
    - [11.2.1. StringBulider类的创建](#1121-stringbulider类的创建)
    - [11.2.2. StringBuilder类的添加和反转](#1122-stringbuilder类的添加和反转)
  - [11.3. StringBulider和String相互转换](#113-stringbulider和string相互转换)
- [12. 集合](#12-集合)
  - [12.1. 集合基础](#121-集合基础)
    - [12.1.1. ArrayList构造方法和添加方法](#1211-arraylist构造方法和添加方法)
    - [12.1.2. ArrayList集合常用方法](#1212-arraylist集合常用方法)
  - [12.2. 小作业，设计一个学生管理系统](#122-小作业设计一个学生管理系统)
- [13. 继承](#13-继承)
  - [13.1. 继承的好处和弊端](#131-继承的好处和弊端)
      - [13.1.0.1. 什么时候使用继承](#13101-什么时候使用继承)
  - [13.2. 继承中变量的访问特点](#132-继承中变量的访问特点)
  - [13.3. super关键字](#133-super关键字)
  - [13.4. 继承中构造方法的访问特点](#134-继承中构造方法的访问特点)
  - [13.5. 继承中成员方法的访问特点](#135-继承中成员方法的访问特点)
  - [13.6. super内存图](#136-super内存图)
  - [方法重写](#方法重写)
    - [方法重写的注意事项](#方法重写的注意事项)
  - [Java中继承的注意事项](#java中继承的注意事项)
- [包](#包)
  - [导包](#导包)
  - [权限修饰符](#权限修饰符)
  - [状态修饰符](#状态修饰符)
- [多态](#多态)
  - [多态中成员的访问特点](#多态中成员的访问特点)
  - [多态的好处和弊端](#多态的好处和弊端)
  - [多态中的转型](#多态中的转型)
  - [多态转型的内存图解](#多态转型的内存图解)
- [抽象类](#抽象类)
  - [抽象类的特点](#抽象类的特点)
  - [抽象类的成员特点](#抽象类的成员特点)
- [接口](#接口)
  - [接口的特点](#接口的特点)
  - [接口的成员特点](#接口的成员特点)
  - [猫和狗，接口版本](#猫和狗接口版本)
  - [类和接口关系](#类和接口关系)
  - [抽象类和接口区别](#抽象类和接口区别)
- [形参和返回值](#形参和返回值)
- [类名作为形参和返回值](#类名作为形参和返回值)
  - [抽象类名作为形参和返回值](#抽象类名作为形参和返回值)
  - [接口名作为形参和返回值](#接口名作为形参和返回值)
- [内部类](#内部类)
  - [成员内部类](#成员内部类)
  - [局部内部类](#局部内部类)
  - [匿名内部类](#匿名内部类)
    - [匿名内部类在开发中的使用](#匿名内部类在开发中的使用)
- [常用api](#常用api)
  - [Math](#math)
  - [System](#system)
  - [Object类](#object类)
  - [ToString方法](#tostring方法)
  - [equals方法](#equals方法)
  - [Array](#array)
    - [冒泡排序](#冒泡排序)
    - [Interger](#interger)
      - [基本类型包装类](#基本类型包装类)
      - [Interger类的概述和使用](#interger类的概述和使用)
      - [int和String的相互转换](#int和string的相互转换)
  - [基本类型包装类](#基本类型包装类-1)
    - [自动装箱和拆箱](#自动装箱和拆箱)
  - [日期类](#日期类)
    - [Data类概述和构造方法](#data类概述和构造方法)
    - [Data类的常用方法](#data类的常用方法)
    - [SimpleDateFormat类](#simpledateformat类)
    - [日期工具类](#日期工具类)
      - [Calendar类描述](#calendar类描述)
      - [Calendar的常用方法](#calendar的常用方法)

<!-- /TOC -->
# 1. 前置教程
## 1.1. JDK的安装目录
&nbsp;&nbsp;目录名称&nbsp;&nbsp;说明
1. bin&nbsp;该路径下存放了JDK的各种工具命令。**javac**和**jav**就放在这个目录
2. conf&nbsp;该路径下存放了JDK的相关配置
3. include&nbsp;该路径下存放了一些平台特定的头文件
4. jmods&nbsp;该路径存放了JDK各种模块
5. legal&nbsp;该路径存放了JDK各种模块的授权文档
6. lib&nbsp;该路径存放了JDK工具的一些补充JAR包
# 2. 基础语法
## 2.1. 注释
```java
//单行注释
/* 多行
           注释
 */
```
## 2.2. 关键字
被java语言赋予了特别含义的单词，如public，class，void等
关键字的字母全部小写
## 2.3. 常量
1. 字符串常量：用**双引号**的内容
2. 整数常量
3. 小数常量
4. 字符常量：用**单引号**的内容
5. 布尔值和空值null
## 2.4. 数据类型
最小信息单元：位(bit)，最小存储单元：字节(Byte|B)
1. 基本数据类型
   1. 数值型
      1. 整数(byte 128,short 32768,long 2^63)
      2. 浮点数(float E38,double E308)
      3. 字符(char 65535)
   2. 非数值型
      1. 布尔(boolean)
2. 引用数据类型
   1. 类(class)
   2. 接口(interface)
   3. 数组([])
## 2.5. 变量
变量是内存中的一小块区域
强类型语言：变量名、数据类型、变量值
变量使用事项：
1. 一个方法内一个变量名最多只能定义一次
2. 定义变量时需要赋值，且在long和float赋值时要加L和F，因为整形默认值为int，浮点型默认值为double。
## 2.6. 标识符
概念
1. 由数字、字母、下划线(_)及美元符($)组成
2. 不能以数字开头
3. 不能是关键字
4. 区分大小写
约定
小驼峰命名法：方法，变量
1. 标识符是一个单词的时候，首字母小写
2. 标识符由多个单词组成时，第一个单词首字母小写，其他单词首字母大写
大驼峰命名法：类
1. 标识符是一个单词的时候，首字母大写
2. 标识符由多个单词组成的时候，每个单词首字母大写
## 2.7. 类型转换
### 2.7.1. 自动类型转换
double d = 10;
![](自动类型转换.png)
### 2.7.2. 强制类型转换
把一个表示数据范围大的数值或变量赋值给另一个表示数据范围小的变量，一般不使用
int k = (int)88.88;
# 3. 运算符
## 3.1. 算数运算符
**(+ - * /(商,准确商，小数与除数与被除数中最多小数位的数据类型一致) %(余数))**
### 3.1.1. 字符”+“操作
算术表达式中包含多个基本数据类型的时候，整个算术表达式的类型会自动进行提升。等级顺序为byte,short,char->int->long->float->double
char i,c;正确相加结果为：int j = i + c
### 3.1.2. 字符串“+”操作
"it " + "is" = "it is"
666 + "it" = "666it"
"黑马“ + 66 + 4 = “黑马664”
66 + 4 + ”黑马“ = ”70黑马“
字符串中含有数字时，显示和运算从左到右进行，可用括号提升优先级
## 3.2. 赋值运算符
“+=”等运算符隐含了强制类型转换
"-="、"*="、"/="、"%="
```java
int i = 10;
i += 10;//+=的操作包含了强制类型转换
short s = 10;
s = short(s + 10);//需要变换成short类型
```
## 3.3. 自增、自减运算符
i++/++i等价于i = i + 1;    i--
参与操作使用：
int j = i++;
++放在变量后面，则首先赋值，再执行++，反之则先执行++再赋值
## 3.4. 关系运算符
==,!=,>,<,<=,>=
int和float可以进行比较
## 3.5. 逻辑运算符
与   &   
或  |  
异或    ^  
非   ！
## 3.6. 短路逻辑运算符
&&   ||
区别：
```java
int i = 10;
int j = 20;
(i++ > 100) && (j++ > 100);
//此时因为i++>100为假，当使用短路逻辑与运算符时便不再继续运行，i和j最终值为11，20，及j++不再执行
```
短路逻辑运算遵从从左到右运算，当达到终结条件时右边的关系式不再进一步运算
## 3.7. 三元运算符
格式：关系表达式？表达式1：表达式2
a>b?x:y;
计算关系表达式的值，如果为真，则表达式1就是运算结果，否则表达式2为运算结果
## 3.8. 案例
三个数最大值
```java
int a = 150;
int b = 210;
int c = 165;
int max = (a>b?a:b)>c?(a>b?a:b):c;;
```
# 4. 数据输入
```java
import java.util.Scanner
Scanner sc = new Scanner(System.in);
int x = sc.nextInt();
int y = sc.nextInt();
System.out.println("x:" + x);
```
# 5. 流程控制
顺序语句、分支语句、循环语句
## 5.1. if-else语句
```java
if(关系表达式){
    语句体1;
}else{
    语句体2;
}
```
## 5.2. if-elseif-else语句
```java
if(关系表达式1){
    yuju1;
}else if{
    yuju2;
}else{
    yuju3'
}
```
## 5.3. switch 语句
注意switch中每个case都要求有个break;否则会出现case穿透，导致顺序运行case直到遇到break时停止
```java
switch(表达式){
    case 值1:
        yujuti1;
        break;
    case 值2:
        yujti2;
        break;
    case 值3:
        yujuti3;
        break;
    default:
        yujuti4;//因为default在最后，可以不要break
}
//简化版
swicth(表达式){
    case 1:case 2:case 3:
        yujuti1;
        break;
    case 4:case
}
```
## 5.4. for循环语句
### 5.4.1. for循环语句格式
for循环中的变量i,j,k这些只能在循环内部使用
```java
for (初始化条件;条件判断句;条件控制句){
    循环体语句;
}
for循环死循环格式：
for(;;){
    循环体语句
}//ctrl+c结束死循环
```
## 5.5. while循环语句
while语句的变量因为定义在循环体外部，所以能在循环结束后再循环外部使用
```java
基本格式：
while(条件判断){
    循环体语句;
}  

完整格式：
初始化语句;
while(条件判断语句){
    循环体语句;
    条件控制语句;
}

死循环格式：
while(true){
    循环体语句
}//ctrl+c结束死循环
```
## 5.6. do...while循环语句
至少会执行一次循环体
```java
基本格式
do {
    循环体语句;
}while(条件判断语句);  

完整格式
初始化语句；
do{
    循环体语句;
    条件控制语句;
}while(条件判断句);
```
## 5.7. 跳转控制语句
跳过某次循环体内容：continue  
结束循环体运行：break
## 5.8. 循环嵌套
不同|相同循环嵌套
## 5.9. Random
```java
导包:import java.util.Random;  
创建对象:Random r = new Random();  
获取随机数:int number = r.nextInt(10);//获取的数据范围[0,10)，包括0不包括10
```
# 6. IDEA
## 6.1. IDEA中项目结构
项目以下很多模块，模块中有很多包，包下有很多java文件
## 6.2. IDEA中内容辅助键和快捷键
### 6.2.1. 快速生成语句
快速生成main()方法：psvm，回车  
快速生成输出语句：sout，回车
### 6.2.2. 内容辅助键
Ctrl+Alt+space(内容补全、内容提示等)
### 6.2.3. 注释
单行注释：Ctrl+/
多行注释：Ctrl+Shift+/
### 6.2.4. 格式化
格式化的是将代码格式成标准格式
Ctrl+Alt+L
## 6.3. IDEA中新建模块|删除模块|导入模块
# 7. 数组
用于存储多个相同数据类型的数据
## 7.1. 数组定义格式
```java
格式1：（推荐）
int[] arr
定义了一个int类型的数组，数组名是arr  
格式2：
int arr[]
定义了一个int型的变量，变量名是arr数组
```
## 7.2. 数组初始化之动态初始化
### 7.2.1. 动态初始化
初始化时只指定数组长度，由系统为数组分配初始值
```java
int[] arr = new int[3];//生成的数组元素都为0
左边：
    int:说明数组中的元素类型是int
    []:说明是一个数组
    arr:数组名称
右边：
    new:为数组申请内存空间
    int:说明数组中的元素类型是int
    []:说明这是一个数组
    3:数组长度
```
### 7.2.2. 静态初始化
int[] arr={1,2,3};
## 7.3. 数组元素访问
数组名[索引]，从0开始的编号  
arr:数组名，空间地址  
arr[0],arr[1],arr[2]  
## 7.4. java中内存分配
int[] arr = new int[3];  
首先new int[3]申请一个长度为3的数组，地址名为mmm1，这个内存称为堆内存  
#### 7.4.0.1. 堆内存
存储new出来的内容，数组在初始化时，会为存储空间添加默认值，每一个new出来的东西都有一个地址值是，使用完毕后被回收

然后将int[]类型的arr变量指向该内存地址，故直接打印arr输出为mmm1，变量arr成为栈内存，定义在方法中的变量，使用完毕，立即消失
而arr[0]即指向内存后的第一个元素值，即数据
```java
int[] arr2 = arr;//赋值的为地址，结果为两个数组堆内存地址相同
```
## 7.5. 数组中两个常见小问题
* 防止索引不存在造成索引越界
* 防止将栈内存指向null空值
## 7.6. 数组常见操作
### 7.6.1. 遍历
用循环进行遍历，获取元素个数：arr.length，注意元素个数遍历时应减1。
```java
for (int i=0;i<arr.length;i++){

}
```
### 7.6.2. 获取最值(排序|变量存储最大值)
# 8. 方法
## 8.1. 概述
方法是将具有独立功能的代码块组织成一个整体，使其具有特殊功能的代码集
* 方法必须先创建才可以使用，该过程成为方法定义
* 方法创建后并不是直接运行的，需要手动使用后才能执行，该过程成为方法调用

## 8.2. 方法定义
```java
public static 数据类型(一般void) 方法名(){
    //方法体
}
```
## 8.3. 方法注意事项
* 方法不能嵌套，方法之间是独立的
* void表示无返回值，可以省略return ，也可以单独的书写return，后面不加数据

## 8.4. 方法重载
指同一个类中定义的多个方法之间的关系，满足以下条件的多个方法相互构成重载
* 多个方法在同一个类中
* 多个方法方法名相同
* 多个方法参数不相同，类型不同或数量不同  
特点：  
* 重载仅对应方法的定义，与方法的调用无关，调用方式参考标准格式
* 重载仅针对同一个类中方法的名称与参数进行识别，与**返回值**无关，即不能通过返回值来判定两个方法是否相互重载

## 8.5. 方法参数传递 
方法中参数不影响方法外参数
数组传入方法时因为传递的是地址，所以在方法中改变数组数据时方法外也会改变
## 8.6. ps:print(ln)
* System.out.println();//输出内容并换行，单独使用可起到换行作用
* System.out.print();//输出内容不换行
# 9. Debug
idea有自动导包，不需要手动导包
# 10. 类和对象
new对象  
类：对现实生活中一类具有共同属性和行为的事物的抽象
特点
* 类时对象的数据类型
* 类是具有相同属性和行为的一组对象的集合  

属性：对象具有的各种特征，每个对象的每个属性都拥有特定的值  
行为：对象能够执行的操作  
#### 10.0.0.1. 类：手机（现实生活中一类具有共同属性和行为的事物的抽象）
属性：品牌、价格
行为：打电话，发短信
## 10.1. 类的定义
类是Java程序的基本组成单位  
**类**=**属性（成员变量）**+**行为（成员方法，去点static关键字）**  
## 10.2. 对象的使用
成员变量：类中方法外的变量，在堆内存，随着对象的存在而存在，对象消失则消失，**有默认的初始化值**
局部变量：方法中的变量，在栈内存，方法使用后即消失，**没有默认初始值，必须先定义赋值**
```java
Phone p = new Phone();
//使用成员变量
p.brand
//使用成员方法
p.call()
```
## 10.3. private关键字
private关键字：权限修饰符，可以修饰成员，保护成员不被别的成员使用，被**private**修饰的成员只能在本类中才能访问  
针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作：
* 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰
* 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰
## 10.4. this关键字
* 用来指代变量名称  ，解决局部变量隐藏成员变量
* 方法被哪个对象调用，this就代表哪个对象，如调用对象s1中的方法，此时this等价于s1。其指向类本身
* 用 this.name 修饰name时，this.name 指的是**成员变量**，而name指的是局部变量  
* 当方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量
## 10.5. this内存原理
与数组、类-成员原理相似
## 10.6. 封装
**面向对象三大特征：封装、继承、多态**
封装时面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的
封装原则：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的fetXxx()/setXxx()方法
## 10.7. 构造方法
构造方法是一种特殊方法，作用是**创建对象**，**完成对象数据的初始化**  
对于工具类，一般将无参构造方法设为private即私有类
```java
public Student(){}//无参构造方法
public Student(String name){
        this.name = name;
        System.out.println("name");
    }
public Student(int age){
        this.age = age;
        System.out.println("age");
    }

Student s1 = new Student();
Student s2 = new Student("林青霞");
Student s3 = new Student(12)
```
### 10.7.1. 注意事项
* 当一个类中没有构造方法时，系统会给出一个默认的无参构造方法
* 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法
* **推荐无论是否使用构造方法，都手写无参数构造方法**
## 10.8. 标准类制作
# 11. API
* 调用方法时，如果方法有明确的返回值，我们用变量接收可以手动完成，也可以使用快捷键的方式完成Ctrl+Alt+V
sc.nextLine();==>String line = sc.next.Line();
## 11.1. String
字符串不变，它们的值在创建后是无法更改的，但可以被共享。
字符串效果上相当于字符串组(char[ ])，但是底层原理是字节数组(byte[ ])  
### 11.1.1. String构造方法
|方法名|说明|
|:--|:--|
|public String()|创建一个空白字符串对象，不含有任何内容|
|public String(char[] chs)|根据字符数组的内容来创建字符串对象|
|public String(byte[] bys)|根据字节数组的内容，来创建字符串对象|
|String s = "abc";|直接赋值的方式创建字符串对象，内容就是abc|  

"abc"这种常量池的地址相同，而通过new String("abc")创建的两个字符串对象指向的是String对象的地址，此时两者地址不同
### 11.1.2. 字符串的比较
|符号|作用|
|:--|:--|
|==|基本类型：比较的是数据值是否相同<br>引用类型：比较的是地址值是否相同</br>|
|equals()|s1.equals(s2);比较字符串内容|

* 数组长度：数组名.length
* 字符串长度：字符串对象.length()
* 字符串获取某个位置的字符：字符串.charAt(int index)
* 判断字符串是大小写、数字、符号等只需要对ch限定范围即可，如ch>='A' && ch<='Z'

## 11.2. StringBulider
```java
String s = "hello";
s += "world";
```
此时"hello","world","helloworld"都会占用空间，造成浪费，而StringBulider类就能解决改问题。  
该类为可变的字符串
### 11.2.1. StringBulider类的创建
```java
StringBuilder sb2 = new StringBuilder("hello");
```
### 11.2.2. StringBuilder类的添加和反转
```java
sb2.append("world").append("   ").append("hahha");//链式调用
sb2.reverse();//反转
```
## 11.3. StringBulider和String相互转换
```java
StringBuilder sb2 = new StringBuilder("hello");
String s2 = sb2.toString();
StringBuilder s3 = new StringBuilder(s2);
```
# 12. 集合
提供一种存储空间可变的数据类型  
ArrayList，可调整大小的数组实现  
它是一种特殊的数据类型，泛型

## 12.1. 集合基础
### 12.1.1. ArrayList构造方法和添加方法
```java
ArrayList<String> array = new ArrayList<>();
array.add("world");//返回值为boolean类型，表示添加是否成功
array.add(2,"javase");//指定位置处添加，注意不要超过最大索引位置+1
```
### 12.1.2. ArrayList集合常用方法
修改是array.set(index,类);
```java
ArrayList<String> array = new ArrayList<>();
    array.add("n1");//添加
    array.add("n2");
    array.add("n3");
    array.add("n4");
    System.out.println(array);
    array.remove(2);//根据索引删除，当没有该元素时返回false
    System.out.println(array);
    array.remove("n1");//根据元素删除
    System.out.println(array);
    System.out.println(set(1,"javase"));//【**修改**】指定位置的元素
    System.out.println(array.get(0));//得到索引处元素数据
    System.out.println(array.size());//得到array元素个数
```
## 12.2. 小作业，设计一个学生管理系统
* 快捷键Alt+Insert能够自动生成构造函数及get/set方法，根据自己需要进行选择
* System.exit(0);//退出程序
* \t是tab键的意思，作用是进行缩进

```java
switch (line){
  case "1":
    bulabula;
    break;
  case "2":
    bulabula;
    break;
  default:
    bulabula;
}
```
# 13. 继承
面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。
子类不仅有自己的方法，还能有父类方法
```java
public class Zi extends Fu{}
//父类成为基类，超类
//子类被称为派生类
```

## 13.1. 继承的好处和弊端
好处：
* 提高了代码的**复用性**（多个类相同的成员可以放到同一个类中）
* 提高了代码的**维护性**（如果方法的代码需要修改，修改一处即可）
弊端：
* 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生关系时子类实现也不得不跟着变化，消弱了子类的独立性
#### 13.1.0.1. 什么时候使用继承
继承体现的关系：is a
假设法：有两个类A和B，如果他们满足A是B的一种，或者B是A的一种，就说明它们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不能滥用继承
举例：苹果和水果√，猫和动物√，猫和狗×
## 13.2. 继承中变量的访问特点
子类在查找变量首先在方法内部查找成员变量，再在子类中查找，最后在父类中查找，如果没有则报错
## 13.3. super关键字
访问本类的成员变量：this.name
访问父类的成员变量：super.name
访问本类成员方法：this.成员方法()
访问父类成员方法：super.成员方法()
访问本类构造方法：构造方法第一行 为this()
访问父类构造方法：构造方法第一句为super()
## 13.4. 继承中构造方法的访问特点
子类中所有的构造方法默认都会访问父类中无参的构造方法
* 子类会继承父类中的数据，可能还会使用父类中的数据，所以子类初始化前，一点先完成父类数据的初始化
* 每个子类构造方法的第一条语句默认都是super()，等价于Fu()，即super==Fu类(调用的父类无参构造方法，此时注意要创建一个空的无参构造方法，即```public Fu(){}```)
* 可以通过添加super(age,name);的方式将父类访问有参构造方法

## 13.5. 继承中成员方法的访问特点
成员方法首先在子类中找，再在父类中找，再找不到就报错
## 13.6. super内存图
子类在堆内存中创建地址后，除了加载本身的成员百变量，还会拓展出一个super空间用来存储父类的成员变量
## 方法重写
重写描述：子类中出现了和父类一摸一样的方法声明
方法重写的引用：
* 当子类需要父类的功能，而功能你如果主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容
在子类中重写父类方法，并使用super.方法()继承父类方法，在重写时使用```@Override```注解进行检查重写方法声明的正确性
### 方法重写的注意事项
* 父类中public权限的方法能被子类调用重写，而private权限的方法不能被子类调用重写
* 访问权限为：  
private<默认<protected<public
## Java中继承的注意事项
* Java中类只支持单继承，不支持多继承
* Java中类支持多层继承
* super只能在子类中使用，
# 包
包就是文件夹，作用是对类进行分类管理
编译时自动创建包
javac -d. helloworld.java
java 包的路径.helloworld

## 导包
import com.company.Teacher;
## 权限修饰符
|修饰符|同一个类|同一个类中子类无关类|不同包的子类|不同包的无关类|
|:---|:---|:---|:---|:---|
|private|√||||
|默认|√|√|||
|protected|√|√|√||
|public|√|√|√|√|

## 状态修饰符
final：最终态。可以修饰成员方法，成员变量、类
fianl修饰的方法不能被重写
final修饰的值是常量，不能再次被赋值
final修饰的类是最终类，不能被继承

final修饰局部变量时：
* 变量是引用类型，final修饰指的是基本类型的数据值不能改变
* 变量是引用类型，final修饰指的是基本类型的地址值不能改变

static：是静态。可以修饰成员方法和成员变量  
静态修饰的成员可以通过类名来访问 **（建议）** ，如Student2.university ="北京大学"  
也可以通过对象名来访问，如
s1.university = "北京大学";
特点：被static修饰的所有对象共享，例：给所有人提供饮水机，但每个人都有不同的水杯  

非静态成员方法
* 可以访问所有静态和非静态的成员变量和成员方法；
静态成员方法
* 只可以访问静态的成员变量和方法

# 多态
同一个对象，在不同时刻表现出来的不同形态  
举例：猫  
可以说猫是猫，即猫 cat = new 猫()  
也可以说猫是动物，即动物 animal  = new 猫()  
多态的前提和体现
* 有继承/实现关系
* 有方法重写
* 有父类引用指向子类对象

## 多态中成员的访问特点
成员变量：编译看左边，执行看左边  
成员方法：编译看左边，执行看右边  
因为成员方法有重写，而成员变量没有重写
## 多态的好处和弊端

好处：提高了程序的扩展性，定义方法的时候，使用父类作为参考，将来在使用的时候，使用具体的子类型参与操作  
继承父类，所以能够使用父类的方法
弊端：不能使用子类的特有功能  

## 多态中的转型
* 向上转型   
  从子到父
  父类引用指向子类对象
* 向下转型
  从父到子
  父类引用转为子类对象  
向下转型：
```java
Animal a = new Cat;
Cat c = (Cat) a;
```
通过强制类型转化弥补多态弊端，达到访问子类特有功能的目的。强制类型转换能够进行的原因，是因为a指向的堆内存中的数据块就是Cat类型的，所以能够强制转换。
## 多态转型的内存图解

# 抽象类
抽象类描述
在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类  
定义抽象类的方法：  
将类和方法加上前缀：abstract
## 抽象类的特点
* 抽象类和抽象方法都要用abstract修饰
* 抽象类可以没有抽象方法，但抽象方法一定在抽象类里面
* 抽象子类如果继承重写，必须要继承重写抽象父类中的所有抽象方法
* 抽象类的子类不想重写，则继承Animal中的抽象方法，所以该子类也应该是抽象类
## 抽象类的成员特点
* 成员变量可以是变量，也可以是常量
* 有构造方法，但是不能实例化
* 构造方法的作用是用于子类访问父类数据的初始化
* 成员方法可以有抽象方法，限定子类必须完成某些动作；也可以有非抽象方法，提高代码复用性  
# 接口
接口是一种公共的规范标准，只要符合规范，大家都可以通用
Java中的接口更多的体现在对行为的抽象
## 接口的特点
* 接口用关键字interface修饰，即```public interface 接口名{}```
* 类实现接口用implements表示，```public class 类名 implements 接口名{}```
* 接口不能实例化，但可以参照多态的方式，通过实现类对象实例化，即接口多态  
  多态的形式：具体类多态，抽象类多态，接口多态
  多态的前提：有继承或者实现关系；有方法重写；有父（类/接口）引用指向（子/实现）类对象
* 接口的实现类
  要么重写接口所有的抽象类
  要么是抽象类，但其子类仍需要重写所有对象类

## 接口的成员特点
* 成员变量只能是常量，即默认被 public static final修饰
* 接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在  
  一个类如果没有父类，默认继承自Object类
* 成员方法只能是抽象方法，默认修饰符是Public abstract  
  关于接口中的方法，JDK8和JDK9中有一些新特性  

## 猫和狗，接口版本
* 接口只能调用接口方法，抽象类只能调用抽象类方法
* 在使用时使用具体的子类，因为它具有最多的方法，即接口方法和抽象父类方法  
## 类和接口关系
* 类和类的关系
  继承关系，只能单继承，也可以多层继承
* 类和接口关系
  实现关系，可以单实现，也可以在继承一个类的同时实现多个接口  
* 接口和接口的关系
  继承关系，可以单继承，也可以多继承  
## 抽象类和接口区别
* 成员区别
  抽象类：变量，常量；有构造方法，有抽象方法，也有非抽象方法
  接口：常量，抽象方法
* 关系区别
  类与类：继承，单继承
  类与接口：实现，可以单实现，也可以多实现
  接口与接口：继承，单继承，多继承
* 设计理念区别
  抽象类：对类抽象，包括属性，行为
  接口：对行为抽象，主要是行为
比如门的开open，关close动作，和新加入的报警alarm动作，所有的门都有开和关，只有一部分有报警功能  
做法是将门的开和关作为一个抽象类，alarm作为一个接口，设计一个新的子类:alarmdoor,它继承自抽象类并导入了接口alarm
# 形参和返回值
# 类名作为形参和返回值
方法的形参是类名，其实需要的是该类的对象  ```useCat(Cat c)```  
方法的返回值是类名，其实返回的是该类的对象
 ```java
Cat c = new Cat();
        return c;
```  
##   抽象类名作为形参和返回值
```java
AnimalOperator ao = new AnimalOperator();
        Animal a = new Cat();
        ao.useAnimal(a);
```
* 方法的形参是抽象类名，其实需要的是该抽象类的子类对象
* 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象  
## 接口名作为形参和返回值

* 方法的形参是接口名，其实需要的是该接口的实现类对象  
* 方法的返回值是接口名，其实返回值是该接口的实现类对象
# 内部类
记：类没有{}  
目的：将内部类隐藏起来，不被外面看到，所以修饰符一般用private。   
内部类就是在一个类中定义一个类，即在一个类A的内部定义一个类B，则类B就称为内部类  
* 内部类可以访问外部类的成员，包括私有
* 外部类要访问内部类的成员，必须创建对象
```java
public class Ceshi {
    （修饰符） public class Ceshi2{
        
    }
}
```
* 内部类
* * 在类的成员位置：成员内部类
* * 在类的局部位置：局部内部类
## 成员内部类

```Outer.Inner oi = new Outer().new Inner();```  
或者在成员内部类外进行调用，利用外部类创建方法进行隐式调用  
## 局部内部类
定义：在类内的方法中定义一个类，这个类不能直接被访问，需要在该方法中创建该局部内部类的对象，进而访问局部内部类对象。  
特点：局部内部类能够访问在它之上的所有变量，包括成员变量和局部变量。  
## 匿名内部类
前提：存在一个类或者接口，这里的类可以是具体类也可以是抽象类  
本质：一个继承了该类或者实现了该接口的子类匿名对象，既然是对象，就可以调用方法，也可以赋值给该类或者实现了的接口。  
 
### 匿名内部类在开发中的使用
记：编译看左边，执行看右边

使用匿名内部类，其本质是继承了该类，或者是实现了该接口的子类的匿名对象，省去了新建类继承父类或者实现接口的子类java文件。  
# 常用api
## Math
* 方法重载
* 包含数字运算方法，不需要创建Math对象  
* 没有构造方法，如果类的成员是静态的，可以直接通过类名来调用
* 常用方法：
  
|方法名|说明|
|:---|:---|
|public static int abs(int a)|返回参数的绝对值|
|public static double ceil(double a)|返回大于或等于参数的最小double值，等于一个整数|
|public static double floor(double a)|返回小于或等于参数的最大double值，等于一个整数|
|int round(float a)|按照四舍五入返回最接近参数的int|
|int max(int a,int b)|返回两个int值的较大值|
|int min(int a,int b)|返回两个int值的较小值|
|double pow(double a,double b)|返回a的b次幂|
|double random()|返回值为double的正值随机数，[0.0,1.0)|  

## System

|方法名|说明|
|:---|:---|
|System.currentTimeMillis()|返回当前时间，毫秒为单位|
|System.exit(int status)|终止当前运行的虚拟机，非0表示异常，0表示正常|
## Object类
子类的构造方法默认访问的都是父类的无参构造方法。因为它们的顶级父类只有无参构造方法。  
## ToString方法
sout默认输出s.ToString()
建议所有子类重写该方法，自动生成
## equals方法
默认比较地址。重写方法可比较内容，自动生成
## Array
### 冒泡排序
### Interger
Interger.MIN_VALUE;int范围最小值
Interger.MAX_VALUE;int范围最大值

Interger是最终类，还提供了几种将String和int相互转换的方法，以及其他常量和方法在处理int时非常有用
#### 基本类型包装类
|基本数据类型|包装类|
|:---|:---|
|byte|Byte|
|short|Short|
|int|Interger|
|long|Long|
|float|Float|
|double|Double|
|char|Character|
|boolean|Boolean|

#### Interger类的概述和使用
获得指定int值的Interger实例，使用：
```java
Interger i1 = Interger.valueOf(100);
Interger i2 = Interger.valueOf("100");
```
#### int和String的相互转换
//int转String
String s1 = ""+number;

String s2 = String.valueOf(number);
//String转int
Integer i = Integer.valueOf(s)
int x = i.intValue();//返回Integer的值作为int

int y = Integer.parseInt(s);//静态方法的方式 

* ValueOf返回的是integer的包装类型（对象），底层使用的也是parseInt
* parseInt返回的是int基本类型
## 基本类型包装类
### 自动装箱和拆箱
装箱：把基本数据类型转换为对应的包装类类型
拆箱：把包装类类型转换为对应的基本数据类型
```java
Integer i = Integer.valueOf(100);//手动装箱
Integer ii = 100;//自动装箱

ii = ii.intValue()+200;//ii.intValue这个动作是手动拆箱，然后自动装箱
ii += 200;//自动拆、装箱
// ii +=200;
```
在开发中，如果是引用类型的变量，首先应判断是否是null，然后在进行计算操作。  
只要是对象，在操作前都要进行不为null判断。  
## 日期类
### Data类概述和构造方法
Data代表了一个特定的时间，精确到毫秒  
|方法名|说明|
|:---|:---|
|Data()|分配一个Data对象，并初始化，以便它代表它被分配的时间，精确到毫秒|
|Data(long Data)|分配一个Data对象，并将其初始化为表示从标准基准时间起指定的毫秒数|

### Data类的常用方法
|方法名|说明|
|:---|:---|
|long getTime()|获取的是日期对象从1970年1月1日00:00:00到现在的毫秒值|
|void setTime(long time)|设置时间，给的是毫秒值|

### SimpleDateFormat类
SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。  
日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从'A'到'Z'，以及从'a'到'z'引导的字母被解释为表示日期或时间字符串的组件的模式字母。  
常用的为：
* y  年
* M  月
* d  日
* H  时
* m  分
* s  秒

格式化和解析日期：
```java
final format(Date data);//格式化，从Date到String，将日期格式化成日期/时间字符串
Date d4 = new Date();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
String s = sdf.format(d4);

Date parse(String source);//从给定字符串的开始解析文本以生成日期 
String ss = "2022-02-11 11:11:11";
SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date dd = sdf2.parse(ss);
```
### 日期工具类
* 工具类：构造方法私有，成员方法静态
#### Calendar类描述
Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法。  
Calendar提供了一个类方法getInstance用于获取Calendar对象，其日历字段已使用当前日期和时间初始化’
Calendar c = Calendar.getInstance();  
c.get(Calendar.YEAR)  
c.get(Calendar.MONTH)+1
c.get(Calendar.DATE)  
**注意，获得的月份从0开始！**
#### Calendar的常用方法

|方法名|说明|
|:---|:---|
|get(int field)|返回给定日历字段的值|
|abstract void add(int field,int amount)|根据日历规则，将指定的时间量增加或减少给定的日历字段|
|final void set(int year,int month,int date)|设置当前日历的年月日|

